#include<iostream>
#include<windows.h>

#include "human.h"
#include "CareTaker.h"
using namespace std;

/* 
 * Паттерн Хранитель (Memento) позволяет выносить внутреннее состояние объекта 
 * за его пределы для последующего возможного восстановления объекта без нарушения 
 * принципа инкапсуляции.
 * 
 * Когда использовать Memento
 *    a) Когда нужно сохранить состояние объекта для возможного последующего 
 *       восстановления
 *    b) Когда сохранение состояния должно проходить без нарушения принципа 
 *       инкапсуляции
 *
 * То есть ключевыми понятиями для данного паттерна являются сохранение внутреннего 
 * состояния и инкапсуляция, и важно соблюсти баланс между ними. Ведь, как правило, 
 * если мы не нарушаем инкапсуляцию, то состояние объекта хранится в объекте в 
 * приватных переменных. И не всегда для доступа к этим переменным есть методы или 
 * свойства с сеттерами и геттерами. Например, в игре происходит управление героем, 
 * все состояние которого заключено в нем самом - оружие героя, показатель жизней, 
 * силы, какие-то другие показатели. И нередко может возникнуть ситуация, сохранить 
 * все эти показатели во вне, чтобы в будущем можно было откатиться к предыдущему уровню 
 * и начать игру заново. В этом случае как раз и может помочь паттерн Хранитель.
 */

int main()
{
	SetConsoleOutputCP(1251);
	SetConsoleTitle(L"Паттерн Memento (Хранитель)");

	// создаем объект человека
	Human h("Юрий", "Васильченко", 44);
	cout << endl << h.GetName() << " " << h.GetSurname() << " " << h.GetAge() << endl;

	MemoryState obj;   // Хранитель

	// сохраняем состояние
	obj.SetMemento(h.SaveMemento());
	
	cout << "\nизменяем данные:\n";
	h.SetSurname("Ольховская");
	h.SetName("Тамара");
	h.SetAge(45);
	cout << endl << h.GetName() << " " << h.GetSurname() << " " << h.GetAge() << endl;
	
	// возвращаем состояние
	h.RestoreMemento(obj.GetMemento());
	cout << endl << h.GetName() << " " << h.GetSurname() << " " << h.GetAge()<<endl;

	return 0;
} // main